
-------------------------------------------------------------------------------
What is a parser and what does it do exactly?

A parser is a function whose primary purpose is creating and initializing
an object that is described by the descriptor being used. This object may
be provided as the 'node' argument, but otherwise the parser is expected
to create it. A parser is essentially an __init__ method for nodes, but
one which is dependent on the FieldType instance, not the nodes class.

A parser does a series of initialization steps with a few branching paths
depending on the provided arguments and what the parser is initializing.
While parsers can be designed to operate very differently from one another
(look at the Switch parser), most follow a certain series of steps.

Below is a list of those steps and their branching paths followed by a few
detailed descriptions of each step. Remember, these are simply general
guidelines for how most parsers will operate, and should only be used as a
template for what a parser should do and in what order it should be done.

  1: Block node creation
    If field.is_block is True and node is not provided:
      Create the node.
      Parent the node to the provided parent.
    Else:
      Do nothing

  2: Subtree reading prep work
    If field.is_block is False:
      Do nothing
    Else:
      If field.is_container is True  or  "subtree_parents" is not in kwargs:
        Set the "is_subtree_root" variable to True.
        Set the "parents" variable to a new list.
      Else:
        Set the "is_subtree_root" variable to False.
        Set the "parents" variable to kwargs['subtree_parents']

      Set kwargs['subtree_parents'] to parents

      If SUBTREE is in the descriptor:
        Append the node to parents

  3: Offset adjustment
    If there is a valid parent and POINTER is in the descriptor:
      Set the "offset" variable to the given pointer.
    Elif ALIGN is in the descriptor:
      Align the "offset" variable using the given alignment.

  4: Reading the node
    This step is pretty open ended since anything specific to
    this parser should probably be done here.

    If field.is_data:
      Set the "size" variable to   parent.get_size(attr_index, **kwargs)
      Seek the buffer to offset + root_offset
      Read size number of bytes from the buffer
      Decode the bytes that were read and set parent[attr_index] to it.
    Else:
      Call the parser of each child node in the node

  5: Reading subtrees
    If field.is_block is True  and  is_subtree_root is True:
      Loop over all nodes in parents and call their subtrees parser.

  6: Return the most recent offset.


###  Block node creation  ###
#############################
If the node a field is meant to build will be a Block but it isnt provided,
node must be set to an instance of the correct Block class, usually like so:
    node = (desc.get(BLOCK_CLS, self.py_type)\
        (desc, parent=parent, init_attrs=rawdata is None))

where self is the field instance and desc, parent, and rawdata are arguments
that were provided to the parser.

After creation, the parser must also parent the node to the parent *


###  Subtree reading prep work  ###
###################################
If the field being read is a Block, there is the possibility that the
node will have a subtree, or that its inner nodes could have subtrees.
If the field is a container, or a "subtree_parents" item isn't in kwargs,
the parser will consider itself a subtree_root and a new list will be
placed in kwargs['subtree_parents'].
If a SUBTREE entry exists in the descriptor(meaning the node being initialized
will have a SUBTREE) the node will be appended to kwargs['subtree_parents'].


###  Offset adjustment  ###
###########################
Before reading from the buffer, parsers may check for certain descriptor
entries that adjust the read offset. For example, if a pointer exists in the
descriptor, the offset may need to be set using the following code:
    offset = node.get_meta('POINTER', **kwargs)
or
    offset = parent.get_meta('POINTER', attr_index, **kwargs)

If a pointer doesnt exist, an alignment entry may need to be checked next.
If ALIGN exists, the offset must be adjusted using the following code:
    align = desc.get('ALIGN', 1)
    offset += (align - (offset % align)) % align

The reason for saying 'may' is because alignment and pointers are
never used in certain circumstances. For example, the elements in a
Struct have predefined offsets with the alignment already calculated
into them, so neither alignment nor pointers matter inside a struct. 
Pointers have no meaning for a Switch or BitStruct and alignment
has no meaning for a Switch, BitStruct, bytearray, or bytes.

Pointers should also never be used if there isn't a valid parent.
This is partially because pointers are usually previously parsed data
higher up in the node tree, and if there is no parent there is no tree.
But also if a node that uses a pointer is serialized, its pointer must be
ignored so as to prevent the buffer from becoming excessively large due
to the pointer changing the initial write position to a non-zero offset.


###  Reading the node  ###
##########################
If the node will be a Block, it will already exist by this point and this
section of the parser will be committed to calling the parsers of the nodes
within it and any other properties specific to this field. If the node wont
be a Block instance, it should instead be created in either of two ways:
    1: converting bytes from the provided buffer(rawdata) into a python object
    2: copying a default value (specified in the descriptor or field)

When the node is created from bytes, the parser is responsible for
seeking to the proper offset in the rawdata, reading the appropriate
number of bytes from it, and the decoding them into a python object.
Decoding will often be relegated to the fields decoder function, with the
parser instead simply calling the decoder while providing the bytes read.

Determining the number of bytes to read is done by calling the parents
get_size method while supplying the attr_index and any other needed data.
This is what it usually looks like:
    size = parent.get_size(attr_index, root_offset=root_offset,
                           offset=offset, rawdata=rawdata, **kwargs)

If the node is being made from a default value, the descriptor will be checked
for a DEFAULT entry. If it exists, the node should be set to a copy of it.
If it doesnt, field.default should be called to get a default value like so:
    node = self.default()

After creation, the parser must also parent the node to the parent *


###  Reading the subtrees  ###
##############################
Look at the "subtree" section under terminology to better understand this.

If the node being read is a Block, it can contain a SUBTREE as well
as other nodes which can also contain a SUBTREE. After the node has
had all its subnodes read, the parent of all subtrees within it will
have been collected in the kwargs["subtree_parents"] list.

The parser should now loop over all entries in the parents list and
call the parser of each nodes SUBTREE. The list of parents must be
removed from kwargs before the kwargs are passed to the child parsers.


###  Returning the offset  ###
##############################
After the parser has finished calling the parser of each of its attributes,
it must return the last offset that the last parser it called returned.
This is so the function that called this parser can know where the reading
stopped, usually for the purpose of calling another parser to start there.



* For assigning an attribute to a parent, parsers must use the index notation:
    parent[attr_index] = node

where "attr_index" is another provided argument. 

Using __setattr__ is not allowed since attr_index can be an integer index
into an array. All Block classes are designed to call their __setattr__ if
the given index is not an int or slice. As a result, index notation is much
more flexible and doesnt require somewhat obfuscating usage of magic methods.


-------------------------------------------------------------------------------
Where and why are they used?

#########################################################


-------------------------------------------------------------------------------
What positional and keyword arguments should a parser
function expect and what are their purposes?

required positional:
    self --------- The FieldType instance whose parser function is being run.
                   The fields actual parser method calls its parser function
                   while providing self and passing on all args and kwargs.
                   Essentially the parser function acts like a class method.

    desc --------- The descriptor that describes the node being read.

positional/keyword:
    node --------- The node that this parser would build.
                   If provided, instead of building a new node, the
                   parser will simply re-build this provided one.

    parent ------- The object that this parser must parent the node that it
                   builds to. For parent to be considered valid, attr_index
                   must also be valid. Typically the node is parented to
                   parent using the index notation:
                       parent[attr_index] = node

    attr_index --- The index that the node will be parented to parent. This
                   is typically done using the index notation:
                       parent[attr_index].
                   If attr_index is None it is considered to be invalid and
                   parent is also invalid. This should only ever occur when
                   the topmost parser is called, as there is no parent.
                   In this case, node MUST be provided and valid.

    rawdata ------ The buffer being read from and parsed into python
                   objects such as Blocks, ints, floats, strings, etc.
                   This must either be None(meaning there is no data to parse),
                   or it must have read, seek, peek, and write methods.

    root_offset -- The root offset that all rawdata reading is done from.
                   Pointers and other offsets are relative to this value.

    offset ------- The initial offset that rawdata reading is done from.

Parser functions are allowed to be given arbitrary keyword arguments
in order to be as versatile as they need to be. Because of this they must
make use of **kwargs since unused keyword arguments may be provided.
kwargs must be passed to any meta_getter_setters and parsers being called.