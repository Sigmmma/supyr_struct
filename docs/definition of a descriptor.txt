Terminology:

Block ------ An object that is designed to hold and express parsed data.
BlockDef --- An object which builds a descriptor from given information,
             checks it for errors, and makes sure it contains certain
             entries while generating other entries automatically.
Descriptor - A dictionary which serves as a collection of static
             attributes that describe parsed binary data held in a Block.


-------------------------------------------------------------------------
What are descriptors?

Descriptors are nothing more than dictionaries used for what is described
below. Descriptors should be immutable, as a single descriptor is intended
to be referenced by many thousands of objects(or more). When a descriptor
is created by a BlockDef, the BlockDef converts it into a FrozenDict.

A FrozenDict is an immutable subclass of dict which runs an 'immutify'
routine on its contents on instantiation. Immutify replaces mutable data
with an immutable equivalent, making a FrozenDict as immutable as possible.


-------------------------------------------------------------------------
Where are descriptors used?

All Blocks store a reference to a descriptor in the __slot__ 'DESC'.
This descriptor is used to 'describe' the Block and the data in it.

BlockDefs also store the descriptor which they have generated in
their 'descriptor' attribute. BlockDefs give this descriptor to
the first Block they create when their 'build' method is invoked.

Descriptors are also, by necessity, stored inside other descriptors.
A descriptor that describes a struct also stores the descriptors for
the members of the struture, like ints, floats, strings, etc.

When a descriptor is meant to describe some kind of object that is not
a Block, the descriptor must be inside another descriptor, which is
itself inside a Block. This may sound confusing, so here's an example:

asdf = Struct('some_struct',
     UInt8('some_int8'),
     UInt16('some_int16'),
     UInt32('some_int32')
     )

asdf will be a descriptor that contains descriptors for 'some_int8',
'some_int16', and 'some_int32'. While a Struct can be expressed as a
ListBlock(and can thus have a descriptor), the int attributes of the
struct are regular python ints, which cannot have extra attributes.


-------------------------------------------------------------------------
What do descriptors do?

One thing they do is provide static attributes and attribute alias's.

Descriptors store a dictionary under the key 'NAME_MAP', which maps
the given name of each attribute in a Block to the attribute name it
can actually be found under. For ListBlocks, this can also instead be
the index in the list that the attribute is actually located in.

To better understand, here is the __getattr__ method of Block:

def __getattr__(self, attr_name):
    try:
        return object.__getattribute__(self, attr_name)
    except AttributeError:
        desc = object.__getattribute__(self, "DESC")

        if attr_name in desc['NAME_MAP']:
            return self[desc['NAME_MAP'][attr_name]]
        elif attr_name in desc:
            return desc[attr_name]
        else:
            raise AttributeError("'%s' of type %s has no attribute '%s'" %
                                 (desc.get('NAME', UNNAMED),
                                  type(self), attr_name))

As you can see, one can refer to attributes in a Block by alias
names stored in the NAME_MAP, and one can also access values in
the descriptor as if they were attributes in the Block.

These two lines function the same:
    asdf = some_block[some_block.DESC['NAME_MAP']['some_attribute']]
    asdf = some_block.some_attribute

These two lines also function the same:
    asdf = some_block.DESC['TYPE']
    asdf = some_block.TYPE

In this way, descriptors act similarly to __dict__.


All Blocks make use of __slots__.
This reuse and usage of __slots__ was done specifically to cut down on
the amount of ram used when hundreds of thousands of Blocks are created.
This reuse is the main reason that a descriptor must be immutable,
because it is otherwise as dangerous as using truly global variables.



-------------------------------------------------------------------------
Whats with the ALL_CAPS descriptor keys?

This was a design decision based around the way a descriptor is used.
Since the entries in a descriptor are intended to be static, they are
similar to constants, which are typically denoted in all uppercase.

This was also done to make it so common names like size, name, type, and
value are still available to be used as attribute names in a Block
without having to resort to some awkward use of underscores or whatnot.

The final reason is because it makes it very clear that you are accessing
an entry in the descriptor(rather than a Block attribute) when you do:
    some_block.TYPE    or     some_block.NAME


-------------------------------------------------------------------------
What is in a descriptor?

There are only two types of keys expected to be found in a descriptor,
integers, and strings.

Integers keyed entries are other descriptors which make up the ordered
attributes in the Block that the descriptor is intended to describe.

Strings keyed entries vary in purpose, but they are mostly supplementary
information that helps describe the Block. For example, the 'SIZE' entry
is intended to store something specifying the serialized size of the Block.
'SUB_STRUCT' on the other hand, stores a descriptor which is given to each
of the Blocks in the ArrayBlock. If the SUB_STRUCT descriptor has a Switch
Field as its 'TYPE' entry, you effectively have a variable array of structures.

A minimal descriptor contains a 'TYPE' entry, a 'NAME' entry, and a 'NAME_MAP'
entry. Different Block subclasses may each have different requirements on
what should be in a descriptor. Using the example from before, ArrayBlocks
must have a SUB_STRUCT entry in their descriptor. This SUB_STRUCT entry is
used for building more Blocks in the array and/or knowing how to treat/serialize
the data when the objects contained in the ArrayBlock are not Blocks themselves.







The sanitizer function of the TYPE entry in each descriptor is
responsible for taking a descriptor and 'sanitizing' it.
Sanitizing involves reporting any errors detected and generating
required entries from supplied ones(such as NAME_MAP, ATTR_OFFS,
CASE_MAP, ENTRIES, etc). Sanitizers are called during the course
of a BlockDefs sanitize function being called
