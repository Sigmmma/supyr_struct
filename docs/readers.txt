

-------------------------------------------------------------------------------
Terminology:

Block ------- An object designed to hold and express parsed binary data.
              Blocks act as nodes in trees with the capacity to be a
              parent node, meaning they hold other nodes.

subtree ----- A subtree is an object parented to a Block in a specific
              way which is also parsed and written in a sequence that
              differs from regular nodes.

              Rather than being placed into one of the indices of its
              parent, a subtree is placed into its SUBTREE attribute.
              The SUBTREE attribute can have an alias name, but it is
              internally stored as an objects attribute rather than a
              list entry.

              Readers and writers finish processing the tree they are
              currently in, then proceed to read/write all subtrees
              encountered in the order that they were encountered.

              If a field detects it's a "subtree_root" it will pass around
              a list in kwargs under the key "subtree_parents", which is
              passed to the reader/writer of each subnode within this node.
              If one of these subnodes has a SUBTREE entry in its descriptor,
              the subnode will be appended to kwargs["subtree_root"].

              After all the readers/writers for all nodes within a Block
              have been called, the parents list will be looped over by
              the reader/writer that created it and calls the reader/writer
              of the SUBTREE attribute of each Block in parents.
              When kwargs is passed to the reader/writer, "subtree_parents"
              is removed from kwargs to prevent infinite recursion.

              This change of read/write order is for situations where
              one may, for example, have an array of 4 Y structures
              where each struct describes another array of 4 Z structures,
              but the first array of 4 is stored contiguously, so the
              serialized arrangement of the structures looks like this:
                  [ AY, BY, CY, DY ],
                  [ AZ1, AZ2, AZ3, AZ4 ], 
                  [ BZ1, BZ2, BZ3, BZ4 ], 
                  [ CZ1, CZ2, CZ3, CZ4 ], 
                  [ DZ1, DZ2, DZ3, DZ4 ]
              This occurs often, and having a single SUBTREE attribute
              takes care of any number of structures that need to be
              read/written in this order since you can use an array or
              container of any size for the SUBTREE attribute.

descriptor -- A dictionary which serves as a collection of static attributes
              that describe parsed binary data expressed as a node, one
              of these being a Field instance under the key 'TYPE'.

Field ------- An immutable object with several properties that describe
              a specific kind of node. These properties are mostly bools,
              like is_str, is_struct, is_array, is_enum, is_block, etc,
              but there are also properties like 'enc'(for string and
              numerical encodings), 'endian'(the endianness of the bytes),
              and 'delimiter'(the character a string is delimited with).

              They also store a reader(for reading bytes from a buffer),
              a decoder(for turning those bytes into a python object),
              an encoder(for turning a python object into bytes), and a
              writer(for writing those bytes to a buffer).

              See readers.txt, writers.txt, decoders.txt, encoders.txt,
              sanitizer.txt, and sizecalc.txt for more information.


-------------------------------------------------------------------------------
What is a reader and what does it do exactly?

A reader is a function whose primary purpose is creating and initializing
an object that is described by the descriptor being used. This object may
be provided as the 'node' argument, but otherwise the reader is expected
to create it. A reader is essentially an __init__ method for nodes, but
one which is dependent on the Field instance, not the nodes class.

A reader does a series of initialization steps with a few branching paths
depending on the provided arguments and what the reader is initializing.
While readers can be designed to operate very differently from one another
(look at the Switch reader), most follow a certain series of steps.

Below is a list of those steps and their branching paths followed by a few
detailed descriptions of each step. Remember, these are simply general
guidelines for how most readers will operate, and should only be used as a
template for what a reader should do and in what order it should be done.

  1: Block node creation
    If field.is_block is True and node is not provided:
      Create the node.
      Parent the node to the provided parent.
    Else:
      Do nothing

  2: Subtree reading prep work
    If field.is_block is False:
      Do nothing
    Else:
      If field.is_container is True  or  "subtree_parents" is not in kwargs:
        Set the "is_subtree_root" variable to True.
        Set the "parents" variable to a new list.
      Else:
        Set the "is_subtree_root" variable to False.
        Set the "parents" variable to kwargs['subtree_parents']

      Set kwargs['subtree_parents'] to parents

      If SUBTREE is in the descriptor:
        Append the node to parents

  3: Offset adjustment
    If there is a valid parent and POINTER is in the descriptor:
      Set the "offset" variable to the given pointer.
    Elif ALIGN is in the descriptor:
      Align the "offset" variable using the given alignment.

  4: Reading the node
    This step is pretty open ended since anything specific to
    this reader should probably be done here.

    If field.is_data:
      Set the "size" variable to   parent.get_size(attr_index, **kwargs)
      Seek the buffer to offset + root_offset
      Read size number of bytes from the buffer
      Decode the bytes that were read and set parent[attr_index] to it.
    Else:
      Call the reader of each child node in the node

  5: Reading subtrees
    If field.is_block is True  and  is_subtree_root is True:
      Loop over all nodes in parents and call their subtrees reader.

  6: Return the most recent offset.


###  Block node creation  ###
#############################
If the node a field is meant to build will be a Block but it isnt provided,
node must be set to an instance of the correct Block class, usually like so:
    node = (desc.get(BLOCK_CLS, self.py_type)\
        (desc, parent=parent, init_attrs=rawdata is None))

where self is the field instance and desc, parent, and rawdata are arguments
that were provided to the reader.

After creation, the reader must also parent the node to the parent *


###  Subtree reading prep work  ###
###################################
If the field being read is a Block, there is the possibility that the
node will have a subtree, or that its inner nodes could have subtrees.
If the Field is a container, or a "subtree_parents" item isn't in kwargs,
the reader will consider itself a subtree_root and a new list will be
placed in kwargs['subtree_parents'].
If a SUBTREE entry exists in the descriptor(meaning the node being initialized
will have a SUBTREE) the node will be appended to kwargs['subtree_parents'].


###  Offset adjustment  ###
###########################
Before reading from the buffer, readers may check for certain descriptor
entries that adjust the read offset. For example, if a pointer exists in the
descriptor, the offset may need to be set using the following code:
    offset = node.get_meta('POINTER', **kwargs)
or
    offset = parent.get_meta('POINTER', attr_index, **kwargs)

If a pointer doesnt exist, an alignment entry may need to be checked next.
If ALIGN exists, the offset must be adjusted using the following code:
    align = desc.get('ALIGN', 1)
    offset += (align - (offset % align)) % align

The reason for saying 'may' is because alignment and pointers are
never used in certain circumstances. For example, the elements in a
Struct have predefined offsets with the alignment already calculated
into them, so neither alignment nor pointers matter inside a struct. 
Pointers have no meaning for a Switch or BitStruct and alignment
has no meaning for a Switch, BitStruct, bytearray, or bytes.

Pointers should also never be used if there isn't a valid parent.
This is partially because pointers are usually previously parsed data
higher up in the node tree, and if there is no parent there is no tree.
But also if a node that uses a pointer is serialized, its pointer must be
ignored so as to prevent the buffer from becoming excessively large due
to the pointer changing the initial write position to a non-zero offset.


###  Reading the node  ###
##########################
If the node will be a Block, it will already exist by this point and this
section of the reader will be committed to calling the readers of the nodes
within it and any other properties specific to this field. If the node wont
be a Block instance, it should instead be created in either of two ways:
    1: converting bytes from the provided buffer(rawdata) into a python object
    2: copying a default value (specified in the descriptor or field)

When the node is created from bytes, the reader is responsible for
seeking to the proper offset in the rawdata, reading the appropriate
number of bytes from it, and the decoding them into a python object.
Decoding will often be relegated to the fields decoder function, with the
reader instead simply calling the decoder while providing the bytes read.

Determining the number of bytes to read is done by calling the parents
get_size method while supplying the attr_index and any other needed data.
This is what it usually looks like:
    size = parent.get_size(attr_index, root_offset=root_offset,
                           offset=offset, rawdata=rawdata, **kwargs)

If the node is being made from a default value, the descriptor will be checked
for a DEFAULT entry. If it exists, the node should be set to a copy of it.
If it doesnt, field.default should be called to get a default value like so:
    node = self.default()

After creation, the reader must also parent the node to the parent *


###  Reading the subtrees  ###
##############################
Look at the "subtree" section under terminology to better understand this.

If the node being read is a Block, it can contain a SUBTREE as well
as other nodes which can also contain a SUBTREE. After the node has
had all its subnodes read, the parent of all subtrees within it will
have been collected in the kwargs["subtree_parents"] list.

The reader should now loop over all entries in the parents list and
call the reader of each nodes SUBTREE. The list of parents must be
removed from kwargs before the kwargs are passed to the child readers.


###  Returning the offset  ###
##############################
After the reader has finished calling the reader of each of its attributes,
it must return the last offset that the last reader it called returned.
This is so the function that called this reader can know where the reading
stopped, usually for the purpose of calling another reader to start there.



* For assigning an attribute to a parent, readers must use the index notation:
    parent[attr_index] = node

where "attr_index" is another provided argument. 

Using __setattr__ is not allowed since attr_index can be an integer index
into an array. All Block classes are designed to call their __setattr__ if
the given index is not an int or slice. As a result, index notation is much
more flexible and doesnt require somewhat obfuscating usage of magic methods.


-------------------------------------------------------------------------------
Where and why are they used?

#########################################################


-------------------------------------------------------------------------------
What positional and keyword arguments should a reader
function expect and what are their purposes?

required positional:
    self --------- The Field instance whose reader function is being run.
                   The fields actual reader method calls its reader function
                   while providing self and passing on all args and kwargs.
                   Essentially the reader function acts like a class method.

    desc --------- The descriptor that describes the node being read.

positional/keyword:
    node --------- The node that this reader would build.
                   If provided, instead of building a new node, the
                   reader will simply re-build this provided one.

    parent ------- The object that this reader must parent the node that it
                   builds to. For parent to be considered valid, attr_index
                   must also be valid. Typically the node is parented to
                   parent using the index notation:
                       parent[attr_index] = node

    attr_index --- The index that the node will be parented to parent. This
                   is typically done using the index notation:
                       parent[attr_index].
                   If attr_index is None it is considered to be invalid and
                   parent is also invalid. This should only ever occur when
                   the topmost reader is called, as there is no parent.
                   In this case, node MUST be provided and valid.

    rawdata ------ The buffer being read from and parsed into python
                   objects such as Blocks, ints, floats, strings, etc.
                   This must either be None(meaning there is no data to parse),
                   or it must have read, seek, peek, and write methods.

    root_offset -- The root offset that all rawdata reading is done from.
                   Pointers and other offsets are relative to this value.

    offset ------- The initial offset that rawdata reading is done from.

Reader functions are allowed to be given arbitrary keyword arguments
in order to be as versatile as they need to be. Because of this they must
make use of **kwargs since unused keyword arguments may be provided.
kwargs must be passed to any meta_getter_setters and readers being called.