

-------------------------------------------------------------------------------
Terminology:

Block ------- An object designed to hold and express parsed binary data.
              Blocks act as nodes in trees with the capacity to be a
              parent node, meaning they hold other nodes.

child ------- A child is an object parented to a Block in a specific
              way which is also parsed and written in a sequence that
              differs from the rest of the library.

              Rather than being placed into one of the indices of its
              parent, a child is placed into its CHILD attribute.
              The CHILD attribute can have an alias name, but it is
              internally stored as an object attribute rather than a
              list entry.

              Children are read/written only after every non-child attribute
              of every Block has been parsed/written. If a Field detects
              that it is a "build_root" it will pass around a list in the
              kwargs under the key "parents" which subsequent readers or
              writers will append Blocks to if the Block contains a CHILD.
              After all the readers/writers for all non-child attributes
              have been called, the list of parents will be looped over by
              the reader/writer that created it and calls the reader of the
              CHILD attribute of each Block(parents is removed from kwargs).

              This change of read/write order is for situations where
              one may, for example, have an array of 4 Y structures
              where each struct describes another array of 4 Z structures,
              but the first array of 4 is stored contiguously, so the
              serialized arrangement of the structures looks like this:
                  [ AY, BY, CY, DY ],
                  [ AZ1, AZ2, AZ3, AZ4 ], 
                  [ BZ1, BZ2, BZ3, BZ4 ], 
                  [ CZ1, CZ2, CZ3, CZ4 ], 
                  [ DZ1, DZ2, DZ3, DZ4 ]
              This occurs often, and having a single CHILD attribute
              takes care of any number of structures that need to be
              read/written in this order since you can use an array or
              container of any size for the CHILD attribute.

descriptor -- A dictionary which serves as a collection of static attributes
              that describe parsed binary data expressed as a node, one
              of these being a Field instance under the key 'TYPE'.

Field ------- An immutable object with serveral properties that describe
              a specific kind of node. These properties are mostly bools,
              like is_str, is_struct, is_array, is_enum, is_block, etc,
              but there are also properties like 'enc'(for string and
              numerical encodings), 'endian'(the endianness of the bytes),
              and 'delimiter'(the character a string is delimited with).

              They also store a reader(for reading bytes from a buffer),
              a decoder(for turning those bytes into a python object),
              an encoder(for turning a python object into bytes), and a
              writer(for writing those bytes to a buffer).

              See readers.txt, writers.txt, decoders.txt, encoders.txt,
              sanitizer.txt, and sizecalc.txt for more information.


-------------------------------------------------------------------------------
What is a reader and what does it do exactly?

A reader is a function whose primary purpose is creating and initializing
an object that is described by the descriptor being used. This object may
be provided as the 'node' argument, but otherwise the reader is expected
to create it. A reader is essentially an __init__ method for nodes,
but one which is dependent on the Field instance, not the nodes class.

A reader does a series of initialization steps with a few branching paths
depending on what the reader is initializing and the provided arguments.
While readers can be designed to operate in very different ways from each
other(look at the Switch reader), most follow a specific series of steps.
Below is a list of those steps and their branching paths followed by a
few detailed descriptions of each step:
  1: Node creation
    If a node is not provided:
      Create the node.
      Parent the node to the provided parent.
    Else:
      Do nothing

  2: Child reading prep work
    If field.is_block is False:
      Do nothing
    Else:
      If field.is_container is True  or  "parents" is not in kwargs:
        Set the "is_build_root" variable to True.
        Set the "parents" variable to a new list.
      Else:
        Set the "is_build_root" variable to False.
        Set the "parents" variable to kwargs['parents']

      Set kwargs['parents'] to parents

      If CHILD is in the descriptor:
        Append the node to parents

  3: Offset adjustment
    If there is a valid parent and POINTER is in the descriptor:
      Set the "offset" variable to the given pointer.
    Elif ALIGN is in the descriptor:
      Align the "offset" variable using the given alignment.

  4: Reading the node
    This step is pretty open ended since anything specific to
    this reader should probably be done here.

    If field.is_data:
      Set the "size" variable to   parent.get_size(attr_index, **kwargs)
      Seek the buffer to offset + root_offset
      Read size number of bytes from the buffer
      Decode the bytes that were read and set parent[attr_index] to it.
    Else:
      Call the reader of each child node in the node

  5: Reading children
    If field.is_block is True  and  is_build_root is True:
      Loop over all nodes in kwargs["parents"] and call their childs reader.

  6: Return the most recent offset.


###  Node creation  ###
The node can be created in any one of three ways: converting bytes
from a provided buffer into a python object, copying a default value
(specified in the descriptor or Field), or creating an instance of
the objects class (specified in the descriptor or field).
When the node is created from bytes, the reader is responsible for reading
the data from the buffer and converting it into a python object.
The node creation can be relegated to the field instances decoder function,
and the reader will instead simply call the decoder while providing rawdata.

If node must be created by not having been provided, the reader must also
give it to the "parent" argument as as attribute using the index notation:
    parent[attr_index] = node
where "attr_index" is another provided argument. Using __setattr__ is
not allowed since attr_index can be an integer index into an array.
All Block classes are designed to call their __setattr__ if the given index
is not an int or slice. As a result, index notation is much more flexible.


###  Child reading prep work  ###
If the field being read is a Block, there is the possibility that the node
will have a child, or that its inner nodes could have children. If the Field
is a container, or a "parents" item isn't in kwargs, the reader will consider
itself a build_root and a new list will be placed in kwargs['parents'].
If a CHILD entry exists in the descriptor(meaning the node being initialized
will have a CHILD) the node will be appended to kwargs['parents'].


###  Offset adjustment  ###
Before reading from the buffer, readers may check for certain descriptor
entries that adjust the read offset. For example, if a pointer exists in the
descriptor, the offset may need to be set using the following code:
    offset = node.get_meta('POINTER', **kwargs)
If a pointer doesnt exist, an alignment entry may need to be checked for next.
If one exists, the offset must be adjusted using the following code:
    align = desc.get('ALIGN', 1)
    offset += (align - (offset % align)) % align

The reason for the 'may' is because alignment and pointers are never
used in certain circumstances. For example, the elements in a Struct
have predefined offsets with the alignment already calculated into
them, so neither alignment nor pointer matter inside a struct. 
Pointers have no meaning for a Switch or BitStruct and alignment
has no meaning for a Switch, BitStruct, bytearray, or bytes.

Pointers should also never be used if there isn't a valid parent.
This is partially because pointers are usually previously parsed data
higher up in the node tree, and if there is no parent there is no tree.
Also, if a node that uses a pointer is serialized, its pointer will
be ignored so as to prevent the buffer from becoming excessively large
due to the pointer changing the write position to a non-zero offset.


###  Reading the node  ###
#########################################################


###  Reading the children  ###
Look at the "child" section under terminology to be able to understand this.
#########################################################


###  Returning the offset  ###
After the reader has finished calling the reader of each of its attributes,
it must return the last offset that the last reader it called returned.
This is so the function that called this reader can know where the reading
stopped, usually for the purpose of calling another reader to start there.


-------------------------------------------------------------------------------
Where and why are they used?

#########################################################


-------------------------------------------------------------------------------
What positional and keyword arguments should a reader
function expect and what are their purposes?

required positional:
    self --------- The Field instance whose reader function is being run.
                   The fields actual reader method calls its reader function
                   while providing self and passing on all args and kwargs.
                   Essentially the reader function acts like a class method.

    desc --------- The descriptor that describes the node being read.

positional/keyword:
    node --------- The node that this reader would build.
                   If provided, instead of building a new node, the
                   reader will simply re-build this provided one.

    parent ------- The object that this reader must parent the node that it
                   builds to. For parent to be considered valid, attr_index
                   must also be valid. Typically the node is parented to
                   parent using the index notation:
                       parent[attr_index] = node

    attr_index --- The index that the node will be parented to parent. This
                   is typically done using the index notation:
                       parent[attr_index].
                   If attr_index is None it is considered to be invalid and
                   parent is also invalid. This should only ever occur when
                   the topmost reader is called, as there is no parent.
                   In this case, node MUST be provided and valid.

    rawdata ------ The buffer being read from and parsed into python
                   objects such as Blocks, ints, floats, strings, etc.
                   This must either be None(meaning there is no data to parse),
                   or it must have read, seek, peek, and write methods.

    root_offset -- The root offset that all rawdata reading is done from.
                   Pointers and other offsets are relative to this value.

    offset ------- The initial offset that rawdata reading is done from.

Reader functions are allowed to be given arbitrary keyword arguments
in order to be as versatile as they need to be. Because of this they must
make use of **kwargs since unused keyword arguments may be provided.
kwargs must be passed to any meta_getter_setters and readers being called.